# Slip 12 — A±B, A@B; Gauss Elimination (upper-tri + back-sub); LP with optimize
import numpy as np
from scipy.optimize import linprog

# Q1
A = np.array([[2,4],[1,3]], float)
B = np.array([[0,5],[6,7]], float)
print("Q1) A+B =\n", A+B)
print("Q1) A-B =\n", A-B)
print("Q1) A*B =\n", A@B)

# Q2 from augmented matrix
M = np.array([[3,-2,1,13],[-2,1,4,11],[1,4,-5,-31]], float)
print("\nQ2) Start:\n", M)
# Elimination
M[2] -= (M[2,0]/M[0,0])*M[0]
M[1] -= (M[1,0]/M[0,0])*M[0]
M[2] -= (M[2,1]/M[1,1])*M[1]
print("Upper-tri:\n", M)
U,b = M[:,:-1], M[:,-1]
z = b[2]/U[2,2]; y = (b[1]-U[1,2]*z)/U[1,1]; x = (b[0]-U[0,1]*y-U[0,2]*z)/U[0,0]
print("Q2) (x,y,z) =", (x,y,z))

# Q3 Max 6x1+5x2+4x3 with ≤
c = -np.array([6,5,4])
A_ub = np.array([[1,2,1],[2,1,3]], float)
b_ub = np.array([10,15], float)
res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=[(0,None)]*3, method="highs")
print("Q3) Z* =", -res.fun, " at (x1,x2,x3) =", res.x)
