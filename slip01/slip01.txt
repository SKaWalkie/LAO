# Slip 1 â€” A*B and B*A, check equality; Gauss Elimination; LP with optimize
import numpy as np
from scipy.optimize import linprog

# Q1
A = np.array([[2,4,6],[1,3,5]], dtype=float)
B = np.array([[1,2],[1,0],[1,0]], dtype=float)
BA = B @ A
AB = A @ B
print("Q1) B*A =\n", BA)
print("Q1) A*B =\n", AB)
print("Q1) Are B*A and A*B same? ->", np.allclose(BA, AB))

# Q2 Gauss Elimination (manual steps -> reduce to U then back-substitute)
A2 = np.array([[1,1,1],[2,3,1],[3,1,2]], float)
b2 = np.array([6,11,11], float)
aug = np.c_[A2,b2]
print("\nQ2) Augmented start:\n", aug)

# Eliminate below pivot (1,1)
aug[1] = aug[1] - 2*aug[0]
aug[2] = aug[2] - 3*aug[0]
print("After R2<-R2-2R1, R3<-R3-3R1:\n", aug)

# Eliminate below pivot (2,2)
aug[2] = aug[2] - (aug[2,1]/aug[1,1])*aug[1]
print("After R3<-R3 - (a32/a22) R2:\n", aug)

# Back substitution
U = aug[:,:-1]; y = aug[:,-1]
z = y[2]/U[2,2]
y2 = (y[1]-U[1,2]*z)/U[1,1]
x = (y[0]-U[0,1]*y2-U[0,2]*z)/U[0,0]
print("Q2) Solution (x,y,z) =", (x,y2,z))

# Q3 LP (maximize 3x1+5x2+4x3 subject to given â‰¤) -> use linprog on -c
c = np.array([-3,-5,-4])                    # maximize -> minimize negative
A_ub = np.array([[2,3,0],[0,2,5],[3,2,4]], float)
b_ub = np.array([8,10,15], float)
res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=[(0,None)]*3, method="highs")
print("\nQ3) Optimal value Z =", -res.fun, "at (x1,x2,x3) =", res.x)
